# Snowflake-SI-vA 算法

Snowflake-SI-vA 算法是 Snowflake-SI 算法的变种。Snowflake-SI 算法使用递增序列的低位
作为毫秒计数器，但是这个可能在高并发的过程中发生冲突。 Snowflake-SI-vA 算法则对此进行
了改进，彻底去除了运行过程中发生冲突的可能。

Snowflake-SI-vA 算法为了确保生成的 UUID 的精度，于是使用了 53 位整数作为 UUID 的生成
结果，其位分部如下：

| H |   52 ~ 43  |                     42 ~ 0                  | L |
|:-:|:----------:|:-------------------------------------------:|:-:|
|   | 1111111111 | 1111111111111111111111111111111111111111111 |   |
|   |    MID     |                      UIN                    |   |

如上表，低 43 位是 UUID 序号（UIN，UUID Index Number），它是一个递增序列当前指针和
当前 UNIX 毫秒时间戳的加法和。因此生成的 UUID 仍然是按时间递增的序列。

> 到 2038 年， Unix 毫秒时间戳总共用了 41 个二进制位，但是考虑到递增序列的加和影响，
> 因此额外增加了两位作为额外保留区（Extra Reserved Zone），防止溢出。

高 10 位是机器序号（Machine ID），用于确保在分布式服务中，多个实例同时工作，也不会
生成重复的 UUID。此处固定为 10 位，因此最多允许 1024 个实例同时工作。

## 特点

SI-vA 对 SI 的改进在于：

- 在同一个实例中，它绝对不会生成重复的 UUID。
- 去除了业务时钟，将之与 UUID 序号合二为一，增加了机器序号的可用空间。
- 无需再初始化业务基准时间。

但是同样也有缺点：

- 初始化时必须通过上一次生成的 UUID 重新计算当前递增序列指针。
- 由于去除了业务时钟，因此不能通过业务时钟快速扫描资源。
